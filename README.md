Single file implementation of the Landmark example of https://github.com/RossHartley/invariant-ekf in Python.


# Definitions

# State Definitions

| **Calculation (Code)**     | **Mathematical Form**                                                                                                     | **Paper Reference** | **Description**                                                           | **Representation**        |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------- | ------------------- | ------------------------------------------------------------------------- | ------------------------- |
| `state.X`                  | $\mathbf{X} \in SE(3)$                                                                                                    | Definition          | State matrix representing rotation, velocity, and position                | $SE_K(3)$                 |
| `state.Theta_`             | $\boldsymbol{\Theta} = \begin{bmatrix} \mathbf{b}_g \\ \mathbf{b}_a \end{bmatrix} \in \mathbb{R}^{6}$                     | Definition          | Bias vector containing gyroscope and accelerometer biases                 | $\mathbb{R}^{6}$          |
| `state.P_`                 | $\mathbf{P} \in \mathbb{R}^{n \times n}$                                                                                  | Definition          | Covariance matrix for state uncertainty                                   | $\mathbb{R}^{n \times n}$ |
| `imu_measurement_prev`     | $\tilde{\mathbf{u}} = \begin{bmatrix} \tilde{\boldsymbol{\omega}} \\ \tilde{\mathbf{a}} \end{bmatrix} \in \mathbb{R}^{6}$ | Definition          | Previous IMU measurement, including raw angular velocity and acceleration | $\mathbb{R}^{6}$          |
| `imu_measurement`          | $\tilde{\mathbf{u}} = \begin{bmatrix} \tilde{\boldsymbol{\omega}} \\ \tilde{\mathbf{a}} \end{bmatrix} \in \mathbb{R}^{6}$ | Definition          | Current IMU measurement, including raw angular velocity and acceleration  | $\mathbb{R}^{6}$          |
| `dt`                       | $\Delta t \in \mathbb{R}$                                                                                                 | Definition          | Time step between IMU measurements                                        | $\mathbb{R}$              |
| `R = state.get_rotation()` | $\mathbf{R} \in SO(3)$                                                                                                    | Definition          | Rotation matrix extracted from state                                      | $SO(3)$                   |
| `v = state.get_velocity()` | $\mathbf{v} \in \mathbb{R}^{3}$                                                                                           | Definition          | Velocity vector extracted from state                                      | $\mathbb{R}^{3}$          |
| `p = state.get_position()` | $\mathbf{p} \in \mathbb{R}^{3}$                                                                                           | Definition          | Position vector extracted from state                                      | $\mathbb{R}^{3}$          |
| `state.get_gyro_bias()`    | $\mathbf{b}_g \in \mathbb{R}^{3}$                                                                                         | Definition          | Gyroscope bias extracted from state                                       | $\mathbb{R}^{3}$          |
| `state.get_accel_bias()`   | $\mathbf{b}_a \in \mathbb{R}^{3}$                                                                                         | Definition          | Accelerometer bias extracted from state                                   | $\mathbb{R}^{3}$          |

# Propagate Step

| **Calculation (Code)**                                   | **Mathematical Form**                                                                                           | **Paper Reference** | **Description**                                               | **Representation**                                                            |
| -------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------- | ------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| `w = imu_measurement_prev[:3] - state.get_gyro_bias()`   | $\mathbf{w} = \tilde{\mathbf{\omega}} - \mathbf{b}_g$                                                           | Equation (24)       | Remove gyro bias from IMU measurement                         | $\mathbb{R}^3 \to \mathbb{R}^3$                                               |
| `a = imu_measurement_prev[-3:] - state.get_accel_bias()` | $\mathbf{a} = \tilde{\mathbf{a}} - \mathbf{b}_a$                                                                | Equation (24)       | Remove accelerometer bias from IMU measurement                | $\mathbb{R}^3 \to \mathbb{R}^3$                                               |
| `phi = w * dt`                                           | $\boldsymbol{\phi} = \mathbf{w} \Delta t$                                                                       | Equation (24)       | Compute angular displacement                                  | $\mathbb{R}^3 \to \mathbb{R}^3$                                               |
| `R_pred = R @ so3_Exp(phi)`                              | $\mathbf{R}^+ = \mathbf{R} \exp(\boldsymbol{\phi}^\wedge)$                                                      | Equation (8)        | Propagate orientation using SO(3) exponential map             | $\mathbb{R}^3 \xrightarrow{\wedge} \mathfrak{so}(3) \xrightarrow{\exp} SO(3)$ |
| `v_pred = v + (R @ a + g_) * dt`                         | $\mathbf{v}^+ = \mathbf{v} + (\mathbf{R} \mathbf{a} + \mathbf{g}) \Delta t$                                     | Equation (8)        | Update velocity using acceleration and gravity                | $\mathbb{R}^3 \to \mathbb{R}^3$                                               |
| `p_pred = p + v * dt + 0.5 * (R @ a + g_) * dt * dt`     | $\mathbf{p}^+ = \mathbf{p} + \mathbf{v} \Delta t + \frac{1}{2} (\mathbf{R} \mathbf{a} + \mathbf{g}) \Delta t^2$ | Equation (8)        | Update position using kinematic equations                     | $\mathbb{R}^3 \to \mathbb{R}^3$                                               |
| `A[3:6, 0:3] = so3_wedge(g_.ravel())`                    | $\mathbf{A}_{v, R} = (\mathbf{g})^\wedge$                                                                       | Equation (12)       | Linearized dynamics: effect of gravity on velocity            | $\mathbb{R}^3 \to \mathfrak{so}(3)$                                           |
| `A[6:9, 3:6] = np.eye(3)`                                | $\mathbf{A}_{p, v} = \mathbf{I}$                                                                                | Equation (12)       | Linearized dynamics: velocity affects position                | $\mathbb{R}^{3 \times 3} \to \mathbb{R}^{3 \times 3}$                         |
| `Qk[0:3, 0:3] = Qg`                                      | $\mathbf{Q}_g$                                                                                                  | Section 5.2         | Gyroscope noise covariance                                    | $\mathbb{R}^{3 \times 3} \to \mathbb{R}^{3 \times 3}$                         |
| `Qk[3:6, 3:6] = Qa`                                      | $\mathbf{Q}_a$                                                                                                  | Section 5.2         | Accelerometer noise covariance                                | $\mathbb{R}^{3 \times 3} \to \mathbb{R}^{3 \times 3}$                         |
| `Phi = I + A * dt`                                       | $\boldsymbol{\Phi} = \mathbf{I} + \mathbf{A} \Delta t$                                                          | Equation (13)       | Approx state transition matrix (first-order Taylor expansion) | $\mathfrak{se}_K(3) \xrightarrow{\text{approx}} SE_K(3)$                      |
| `P_pred = Phi @ P_ @ Phi.T + Qk_hat`                     | $\mathbf{P}^+ = \boldsymbol{\Phi} \mathbf{P} \boldsymbol{\Phi}^T + \mathbf{Q}$                                  | Equation (13)       | Propagate covariance matrix                                   | $\mathbb{R}^{n \times n} \to \mathbb{R}^{n \times n}$                         |

# Correction Step

| **Calculation (Code)**                            | **Mathematical Form**                                                                                                                        | **Paper Reference** | **Description**                                            | **Representation**                                                                             |
| ------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- | ---------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| `PHT = P @ obs.H.T`                               | $\mathbf{PHT} = \mathbf{P} \mathbf{H}^T$                                                                                                     | Equation (19)       | Compute the cross-covariance between state and observation | $\mathbb{R}^{n \times n} \to \mathbb{R}^{n \times m}$                                          |
| `S = obs.H @ PHT + obs.N`                         | $\mathbf{S} = \mathbf{H} \mathbf{PHT} + \mathbf{N}$                                                                                          | Equation (19)       | Compute innovation covariance                              | $\mathbb{R}^{n \times m} \to \mathbb{R}^{m \times m}$                                          |
| `K = PHT @ np.linalg.inv(S)`                      | $\mathbf{K} = \mathbf{PHT} \mathbf{S}^{-1}$                                                                                                  | Equation (19)       | Compute Kalman gain                                        | $\mathbb{R}^{n \times m} \to \mathbb{R}^{n \times m}$                                          |
| `BigX = np.kron(np.eye(n_measurements), state.X)` | $\mathbf{BigX} = \mathbf{I} \otimes \mathbf{X}$                                                                                              | Equation (20)       | Construct block-diagonal matrix with repeated state        | $SE_K(3) \to SE_K(3)^{m}$                                                                      |
| `Z = BigX @ obs.Y - obs.b`                        | $\mathbf{Z} = \mathbf{BigX} \mathbf{Y} - \mathbf{b}$                                                                                         | Equation (20)       | Compute measurement residual                               | $SE_K(3)^m \to \mathbb{R}^{m}$                                                                 |
| `delta = K @ obs.PI @ Z`                          | $\boldsymbol{\delta} = \mathbf{K} \mathbf{\Pi} \mathbf{Z}$                                                                                   | Equation (21)       | Compute correction term                                    | $\mathbb{R}^{n \times m} \to \mathbb{R}^{n}$                                                   |
| `dX = sek3_Exp(delta[:-6])`                       | $\mathbf{dX} = \exp(\boldsymbol{\delta})$                                                                                                    | Equation (21)       | Map correction from Lie algebra to Lie group               | $\mathbb{R}^{n} \xrightarrow{\text{reshape}} \mathfrak{se}_K(3) \xrightarrow{\exp} SE_K(3)$ \| |
| `dTheta = delta[-6:]`                             | $\boldsymbol{\Theta}^+ = \boldsymbol{\Theta} + \boldsymbol{\delta}_\Theta$                                                                   | Equation (21)       | Update bias parameters                                     | $\mathbb{R}^{6} \to \mathbb{R}^{6}$                                                            |
| `X_new = dX @ state.X`                            | $\mathbf{X}^+ = \mathbf{dX} \mathbf{X}$                                                                                                      | Equation (21)       | Update state estimate using right-invariant update         | $SE_K(3) \to SE_K(3)$                                                                          |
| `Theta_new = state.Theta_ + dTheta`               | $\boldsymbol{\Theta}^+ = \boldsymbol{\Theta} + \boldsymbol{\delta}_\Theta$                                                                   | Equation (21)       | Update bias parameters                                     | $\mathbb{R}^{6} \to \mathbb{R}^{6}$                                                            |
| `IKH = np.eye(state.P_.shape[0]) - K @ obs.H`     | $\mathbf{I} - \mathbf{K} \mathbf{H}$                                                                                                         | Equation (22)       | Compute Joseph form of covariance update                   | $\mathbb{R}^{n \times n} \to \mathbb{R}^{n \times n}$                                          |
| `P_new = IKH @ P @ IKH.T + K @ obs.N @ K.T`       | $\mathbf{P}^+ = (\mathbf{I} - \mathbf{K} \mathbf{H}) \mathbf{P} (\mathbf{I} - \mathbf{K} \mathbf{H})^T + \mathbf{K} \mathbf{N} \mathbf{K}^T$ | Equation (22)       | Update covariance matrix                                   | $\mathbb{R}^{n \times n} \to \mathbb{R}^{n \times n}$                                          |
