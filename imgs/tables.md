


# Setup Definitions

| **Calculation (Code)**     | **Mathematical Form**                                                                                                     | **Description**                                                           | **Representation**        |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- | ------------------------- |
| `state.X`                  | $\mathbf{X} \in SE(3)$                                                                                                    | State matrix representing rotation, velocity, and position                | $SE_K(3)$                 |
| `state.Theta_`             | $\boldsymbol{\Theta} = \begin{bmatrix} \mathbf{b}_g \\ \mathbf{b}_a \end{bmatrix} \in \mathbb{R}^{6}$                     | Bias vector containing gyroscope and accelerometer biases                 | $\mathbb{R}^{6}$          |
| `state.P_`                 | $\mathbf{P} \in \mathbb{R}^{n \times n}$                                                                                  | Covariance matrix for state uncertainty                                   | $\mathbb{R}^{n \times n}$ |
| `imu_measurement_prev`     | $\tilde{\mathbf{u}} = \begin{bmatrix} \tilde{\boldsymbol{\omega}} \\ \tilde{\mathbf{a}} \end{bmatrix} \in \mathbb{R}^{6}$ | Previous IMU measurement, including raw angular velocity and acceleration | $\mathbb{R}^{6}$          |
| `imu_measurement`          | $\tilde{\mathbf{u}} = \begin{bmatrix} \tilde{\boldsymbol{\omega}} \\ \tilde{\mathbf{a}} \end{bmatrix} \in \mathbb{R}^{6}$ | Current IMU measurement, including raw angular velocity and acceleration  | $\mathbb{R}^{6}$          |
| `dt`                       | $\Delta t \in \mathbb{R}$                                                                                                 | Time step between IMU measurements                                        | $\mathbb{R}$              |
| `R = state.get_rotation()` | $\mathbf{R} \in SO(3)$                                                                                                    | Rotation matrix extracted from state                                      | $SO(3)$                   |
| `v = state.get_velocity()` | $\mathbf{v} \in \mathbb{R}^{3}$                                                                                           | Velocity vector extracted from state                                      | $\mathbb{R}^{3}$          |
| `p = state.get_position()` | $\mathbf{p} \in \mathbb{R}^{3}$                                                                                           | Position vector extracted from state                                      | $\mathbb{R}^{3}$          |
| `state.get_gyro_bias()`    | $\mathbf{b}_g \in \mathbb{R}^{3}$                                                                                         | Gyroscope bias extracted from state                                       | $\mathbb{R}^{3}$          |
| `state.get_accel_bias()`   | $\mathbf{b}_a \in \mathbb{R}^{3}$                                                                                         | Accelerometer bias extracted from state                                   | $\mathbb{R}^{3}$          |
# Propagate Step Definitions

| **Calculation (Code)**                                   | **Mathematical Form**                                                                                           | **Description**                                               | **Representation**                                                            | **Eq ** |
| -------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------- | ----------------------------------------------------------------------------- | ------- |
| `w = imu_measurement_prev[:3] - state.get_gyro_bias()`   | $\mathbf{w} = \tilde{\mathbf{\omega}} - \mathbf{b}_g$                                                           | Remove gyro bias from IMU measurement                         | $\mathbb{R}^3 \to \mathbb{R}^3$                                               | (24)    |
| `a = imu_measurement_prev[-3:] - state.get_accel_bias()` | $\mathbf{a} = \tilde{\mathbf{a}} - \mathbf{b}_a$                                                                | Remove accelerometer bias from IMU measurement                | $\mathbb{R}^3 \to \mathbb{R}^3$                                               | (24)    |
| `phi = w * dt`                                           | $\boldsymbol{\phi} = \mathbf{w} \Delta t$                                                                       | Compute angular displacement                                  | $\mathbb{R}^3 \to \mathbb{R}^3$                                               | (24)    |
| `R_pred = R @ so3_Exp(phi)`                              | $\mathbf{R}^+ = \mathbf{R} \exp(\boldsymbol{\phi}^\wedge)$                                                      | Propagate orientation using SO(3) exponential map             | $\mathbb{R}^3 \xrightarrow{\wedge} \mathfrak{so}(3) \xrightarrow{\exp} SO(3)$ | (8)     |
| `v_pred = v + (R @ a + g_) * dt`                         | $\mathbf{v}^+ = \mathbf{v} + (\mathbf{R} \mathbf{a} + \mathbf{g}) \Delta t$                                     | Update velocity using acceleration and gravity                | $\mathbb{R}^3 \to \mathbb{R}^3$                                               | (8)     |
| `p_pred = p + v * dt + 0.5 * (R @ a + g_) * dt * dt`     | $\mathbf{p}^+ = \mathbf{p} + \mathbf{v} \Delta t + \frac{1}{2} (\mathbf{R} \mathbf{a} + \mathbf{g}) \Delta t^2$ | Update position using kinematic equations                     | $\mathbb{R}^3 \to \mathbb{R}^3$                                               | (8)     |
| `A[3:6, 0:3] = so3_wedge(g_.ravel())`                    | $\mathbf{A}_{v, R} = (\mathbf{g})^\wedge$                                                                       | Linearized dynamics: effect of gravity on velocity            | $\mathbb{R}^3 \to \mathfrak{so}(3)$                                           | (12)    |
| `A[6:9, 3:6] = np.eye(3)`                                | $\mathbf{A}_{p, v} = \mathbf{I}$                                                                                | Linearized dynamics: velocity affects position                | $\mathbb{R}^{3 \times 3} \to \mathbb{R}^{3 \times 3}$                         | (12)    |
| `Qk[0:3, 0:3] = Qg`                                      | $\mathbf{Q}_g$                                                                                                  | Gyroscope noise covariance                                    | $\mathbb{R}^{3 \times 3} \to \mathbb{R}^{3 \times 3}$                         | S5.2    |
| `Qk[3:6, 3:6] = Qa`                                      | $\mathbf{Q}_a$                                                                                                  | Accelerometer noise covariance                                | $\mathbb{R}^{3 \times 3} \to \mathbb{R}^{3 \times 3}$                         | S5.2    |
| `Phi = I + A * dt`                                       | $\boldsymbol{\Phi} = \mathbf{I} + \mathbf{A} \Delta t$                                                          | Approx state transition matrix (first-order Taylor expansion) | $\mathfrak{se}_K(3) \xrightarrow{\text{approx}} SE_K(3)$                      | (13)    |
| `P_pred = Phi @ P_ @ Phi.T + Qk_hat`                     | $\mathbf{P}^+ = \boldsymbol{\Phi} \mathbf{P} \boldsymbol{\Phi}^T + \mathbf{Q}$                                  | Propagate covariance matrix                                   | $\mathbb{R}^{n \times n} \to \mathbb{R}^{n \times n}$                         | (13)    |

# Correction Step Definitions

| **Calculation (Code)**                            | **Mathematical Form**                                                                                                                        | **Description**                                            | **Representation**                                                                          | **Eq** |
| ------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------------------------------------------------- | ------ |
| `PHT = P @ obs.H.T`                               | $\mathbf{PHT} = \mathbf{P} \mathbf{H}^T$                                                                                                     | Compute the cross-covariance between state and observation | $\mathbb{R}^{n \times n} \to \mathbb{R}^{n \times m}$                                       | (19)   |
| `S = obs.H @ PHT + obs.N`                         | $\mathbf{S} = \mathbf{H} \mathbf{PHT} + \mathbf{N}$                                                                                          | Compute innovation covariance                              | $\mathbb{R}^{n \times m} \to \mathbb{R}^{m \times m}$                                       | (19)   |
| `K = PHT @ np.linalg.inv(S)`                      | $\mathbf{K} = \mathbf{PHT} \mathbf{S}^{-1}$                                                                                                  | Compute Kalman gain                                        | $\mathbb{R}^{n \times m} \to \mathbb{R}^{n \times m}$                                       | (19)   |
| `BigX = np.kron(np.eye(n_measurements), state.X)` | $\mathbf{BigX} = \mathbf{I} \otimes \mathbf{X}$                                                                                              | Construct block-diagonal matrix with repeated state        | $SE_K(3) \to SE_K(3)^{m}$                                                                   | (20)   |
| `Z = BigX @ obs.Y - obs.b`                        | $\mathbf{Z} = \mathbf{BigX} \mathbf{Y} - \mathbf{b}$                                                                                         | Compute measurement residual                               | $SE_K(3)^m \to \mathbb{R}^{m}$                                                              | (20)   |
| `delta = K @ obs.PI @ Z`                          | $\boldsymbol{\delta} = \mathbf{K} \mathbf{\Pi} \mathbf{Z}$                                                                                   | Compute correction term                                    | $\mathbb{R}^{n \times m} \to \mathbb{R}^{n}$                                                | (21)   |
| `dX = sek3_Exp(delta[:-6])`                       | $\mathbf{dX} = \exp(\boldsymbol{\delta})$                                                                                                    | Map correction from Lie algebra to Lie group               | $\mathbb{R}^{n} \xrightarrow{\text{reshape}} \mathfrak{se}_K(3) \xrightarrow{\exp} SE_K(3)$ | (21)   |
| `dTheta = delta[-6:]`                             | $\boldsymbol{\Theta}^+ = \boldsymbol{\Theta} + \boldsymbol{\delta}_\Theta$                                                                   | Update bias parameters                                     | $\mathbb{R}^{6} \to \mathbb{R}^{6}$                                                         | (21)   |
| `X_new = dX @ state.X`                            | $\mathbf{X}^+ = \mathbf{dX} \mathbf{X}$                                                                                                      | Update state estimate using right-invariant update         | $SE_K(3) \to SE_K(3)$                                                                       | (21)   |
| `Theta_new = state.Theta_ + dTheta`               | $\boldsymbol{\Theta}^+ = \boldsymbol{\Theta} + \boldsymbol{\delta}_\Theta$                                                                   | Update bias parameters                                     | $\mathbb{R}^{6} \to \mathbb{R}^{6}$                                                         | (21)   |
| `IKH = np.eye(state.P_.shape[0]) - K @ obs.H`     | $\mathbf{I} - \mathbf{K} \mathbf{H}$                                                                                                         | Compute Joseph form of covariance update                   | $\mathbb{R}^{n \times n} \to \mathbb{R}^{n \times n}$                                       | (22)   |
| `P_new = IKH @ P @ IKH.T + K @ obs.N @ K.T`       | $\mathbf{P}^+ = (\mathbf{I} - \mathbf{K} \mathbf{H}) \mathbf{P} (\mathbf{I} - \mathbf{K} \mathbf{H})^T + \mathbf{K} \mathbf{N} \mathbf{K}^T$ | Update covariance matrix                                   | $\mathbb{R}^{n \times n} \to \mathbb{R}^{n \times n}$                                       | (22)   |
